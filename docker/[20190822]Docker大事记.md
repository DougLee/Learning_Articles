# Docker大事记



## 暂露头角

2013年前后, 以Cloud Foundry为代表的PaaS项目, 逐渐完成了教育用户和开拓市场的艰巨任务. 在将PaaS概念逐渐落地的过程中, 应用打包困难这个问题, 逐渐成了技术圈子的一块心病. 

PaaS之所以能够帮助用户大规模部署应用到及群里, 是因为它提供了一套应用打包的功能, 一旦用上了PaaS, 用户就必须为每种语言, 每种框架甚至每个版本的应用维护一个打好的包. 这个打包的工程十分复杂, 并且没有章法可循. 最终的结局就是PaaS确实能实现一键部署, 但是为了实现这个一键部署, 用户为每个应用打包的工作可谓费尽心机.

当时还名叫dotDocker的Docker公司提供了一种非常便利的打包机制, 解决了打包这个根本的问题, 给PaaS世界带来了降维打击. 这种机制直接打包了应用运行所需要的整个操作系统, 从而保证了本地环境和云端环境的高度一致, 避免了通过不断"试错"来匹配两种不同运行环境之间差异的痛苦过程,  这种机制就是镜像. 

这时候的Docker虽然解决了应用打包的难题, 但是并不能替代PaaS完成大规模部署应用的职责. 

考虑到Docker公司是一个与自己有潜在竞争关系的商业实体, 再加上对Docker项目普及程度的错误判断, Cloud Foundry项目并没有第一时间使用Docker作为自己的核心依赖去替代饱受诟病的打包流程. 反倒是一些机敏的创业公司纷纷在第一时间推出了Docker容器管理的项目, 它们一般称自己为CaaS(Container-as-a-Service), 用来跟过时的PaaS划清界限.

## 群雄并起

虽然Docker项目备受追捧, 但用户最终要部署的还是他们的网站, 服务, 数据库甚至是云计算业务. 这也就意味着只有那些能够为用户提供平台层能力的工具, 才会最终成功开发者们关心和愿意付费的产品. 而Docker这样一个只能用来创建和启停容器的小工具, 最终只能充当这些平台项目的幕后英雄.

提到Docker项目的定位问题就不得不提Docker公司的老朋友和老对手CoreOS.

CoreOS是一个基础设施领域创业公司. 它的核心产品是一个定制化的操作系统, 用户可以按照分布式集群的方式管理所有安装了这个操作系统的节点, 使用户在及权利部署和管理应用就想使用单机一样方便.  Docker项目发布之后, CoreOS公司意识到可以把"容器"的概念无缝集成到自己的这套方案中, 从而为用户提供更高层次的PaaS人能力. 所以, CoreOS很早就成了Docker项目的贡献者, 并在段时间内成为了Docker项目中第二重要的力量. 

然而源于Docker公司对Docker项目定位的不满足,  Docker项目不断向PaaS项目进化, 提供了更多的平台层能力, 并于2014年12的DockerCon上发布了Swarm, 这就与CoreOS公司的核心产品和战略发生了严重冲突. 所以, CoreOS公司在2014年底以强烈的措辞宣布与Docker公司停止合作, 并推出了自己研制的Rocket容器(后来的rkt).

当然Swarm只是Docker公司重新定义PaaS的关键一环而已. 在2014~2015年间, Docker项目的迅速走红催生出了一个非常繁荣的Docker生态. 围绕着Docker在各个层次进行集成和创新的项目层出不穷. 此时已经不差钱的Docker公司收购了Fig项目, 后来改名为Compose, 知道今天还有很多人在使用.

出了繁荣的Docker公司和生态之外, 还有一个势力在当时也是风头无两, 老牌集群管理项目Mesos和它背后的创业公司Mesosphere.

Mesos社区虽然不能提供像Swarm那样原生Docker API, 但是却拥有一个独特的竞争力: 超大规模集群的管理经验. Mesosphere公司发布了一个名为Marathon的项目, 这个项目很快就成为了Docker Swarm的一个有力竞争对手.

Mesos社区的优势在于超大规模集群的管理经验. 早在几年前Mesos就已经通过了万台节点的验证, 2014年之后又被广泛使用在eBay等大型互联网公司的生产环境中. 而这次通过Marathon实现了诸如应用托管和负载均衡的PaaS功能之后, Mesos+Marathon的组合实际上进化成了一个高度成熟的PaaS项目, 同时还能很好的地支持大数据业务. 这对很多大型企业来说具有着非同寻常的吸引力.

而这时候的CoreOS和RedHat处境就不那么乐观了, 同样是Docker项目早期的重要贡献者, 同样是因为对Docker公司平台化战略不满而退出. 他们已经跟Docker Swarm和转型后的Meosos完全不在同一个竞技水平之上.

2014年注定是一个神奇的年份, 就在这一年的6月, Google突然发力正式宣告了一个名叫Kubernetes项目的诞生. 这个项目不但挽救了当时的CoreOS和RedHat, 还如同当年Docker项目的横空出世一样, 再一次改变了整个容器市场的格局.

## 尘埃落定

### OCI的成立

当初Docker项目刚刚兴起的时候, Google也开源了一个再内部使用多年, 经历过生产环境验证的Linux容器: Lmctfy(Let Me Container That For You). 但是对用户没那么友好的Google容器项目面对Docker的强势崛起根本没有招架之力. 所以知难而退的Google向Docker公司表达了合作的愿望: 关停Lmctfy项目, 和Docker公司共同推进一个中立的容器运行时库作为Docker项目的核心依赖. Docker公司不出意外的没有同意这个明显会削弱自己地位的提议.  而是在不久后自己匆忙发布了一个容器运行时库LibContainer.

Docker公司在容器运行时层面上的强硬态度和Docker项目在高速迭代中表现出来的不稳定和频繁变更等问题, 开始让社区叫苦不迭.

在2015年, 容器领域的其他几位玩家开始商议削弱Docker项目的话语权. 削弱的手段也非常经典, 成立一个中立的基金会. 于是在2015年6月22日, 由Docker公司牵头, CoreOS, Google, RedHat等公司共同宣布, Docker公司将LibContainer捐出, 改名为RunC项目, 交由一个完全中立的基金会管理, 然后以RunC为依据大家共同执行一套容器和镜像的标准和规范. 这套标准和规范就是OCI(Open Container Initiative).

尽管Docker是OCI的发起者和创始成员, 但是它却很少在OCI的技术推进和标准制定等事务上扮演关键角色, 也就没有动力去积极地推进这些所谓的标准. 这也是迄今为止OCI组织效率持续底下的根本原因.

### CNCF的成立

眼看着OCI没能改变Docker公司一加独大的现状, Google和RedHat拿出了另一个武器. 

Docker之所以不担心OCI的威胁原因就在于它的Docker项目是容器生态的事实标准, 而它所维护的Docker社区也足够庞大. 可是一旦这场斗争呗转移到容器之上的平台层, 或者说PaaS层, Docker公司的竞争优势就荡然无存了. 在这个领域里, 像Google和RedHat这样的成熟公司都拥有着深厚的技术积累, CoreOS这样的创业公司也拥有想Etcd这样被广泛使用的开源基础设施项目, Docker公司呢, 只有一个Swarm.

所以, Google, RedHat等开源基础设施领域的玩家们共同前童发起了一个名为CNCF(Cloud Native Computing Foundation)的基金会. 这个基金会的目的就是希望以Kubernetes项目为基础, 建立一个由开源基础设施领域厂商主导的, 按照独立基金会方式运营的平台级社区, 来对抗以Docker公司为核心的容器商业生态.

### 三国鼎立

CNCF为了打造出一个围绕Kubernetes项目的"护城河", 至少需要保证两件事情:

1. Kubernetes项目必须能够在容器编排领域取得足够大的竞争优势;
2. CNCF社区必须以Kubernetes项目为核心, 覆盖足够多的场景.

在容器编排领域, Kubernetes项目需要面对来自Docker公司和Mesos社区两个方向的压力.  Docker公司的Swarm和Mesos实际上分别从两个不同的方向做了各自擅长的事: 

+ Swarm擅长的是跟Docker生态的无缝集成
+ Mesos擅长的则是大规模集群的管理与调度

这两个方向也是大多数人做容器管理项目时最容器想到的两个出发点. 作为后来者, Kubernetes项目如果在这两个方向上发力就不太明智了. 所以Kubernetes选择的应对方式是: Borg.

Borg 是谷歌公司的内部容器管理系统。早在十几年前，该公司就已经部署 Borg 系统对来自于几千个应用程序所提交的 job 进行接收、调试、启动、停止、重启和监控。该项目的目的是实现资源管理的自动化以及跨多个数据中心的资源利用率最大化。而Kubernetes就是将 Borg 最精华的部分提取出来, 比如Pod, Sidecar等功能和设计模式. 

Kubernetes项目的基础特性是Google公司在容器化基础设施多年来实践经验的沉淀与升华. 这正是Kubernetes项目能够从一开始就避免同Swarm和Mesos社区同质化的重要手段, 这也算是在Kubernetes项目发布初期很多人抱怨器设计思想过于超前的原因.

由于Kubernetes初期团队规模很小, 把这些先进的思想通过技术手段落地并培育出一个认同这些理念和生态的过程中RedHAT发挥了重要的作用. RedHat是世界上为数不多的能真正理解开源社区运作和项目研发真谛的合作伙伴.

随着Kubernetes项目影响力的不断扩大, 也正是开启了容器编排领域三国鼎立的局面.

### Moby项目的成立

Kubernetes项目让人耳目一新的设计理念和号召力很快就构建出了一个与众不同的容器编排与管理的生态, 逐渐将Docker公司的Swarm项目甩在了身后.

在看到了CNCF社区对用户表现出来的巨大吸引力后, 大量的公司和创业团队开始针对CNCF社区而不是Docker公司制定推广策略. 这时候Docker公司面对这样的竞争态势, Docker公司意识到了Swarm项目目前唯一的优势就是跟Docker项目的无缝集成, 所以在2016年宣布了一个震惊所有人的计划: 放弃现有的Swarm项目, 将容器编排和集群管理功能全部内置到Docker项目中.

反观Kubernetes则反其道而行之, 开始在整个社区推进民主化架构, 从API到容器运行时的每一层, Kubernetes项目都为开发者暴露出了可以扩展的插件机制, 鼓励用户通过代码的方式介入到Kubernetes项目的每一个阶段. 这个变革的效果立竿见影, 很快催生出了大量的基于Kubernetes API和扩展接口的二次创新工作, 例如现在热度极高的微服务治理项目lstio等.

在这种鼓励二次创新的整体氛围当中, Kubernetes社区在2016年后得到了空前的发展. 更重要的是, 不同于之前局限于"打包, 发布"这样的PaaS化路线, 这一次容器社区的繁荣, 完全是以Kubernetes为核心的百花争鸣.

面对Kubernetes社区的崛起和强大, Docker公司实际上已没有什么回旋的余地, 在早期拒绝了微软的天价收购之后, Docker公司只能选择逐步放弃开源社区而专注于自己的商业化转型.
从2017年开始, Docker公司先是将Docker项目的运行时部分Containerd捐赠给CNCF社区, 标志着Docker项目已经全面升级成一个PaaS平台; 紧接着, Docker公司宣布将Docker项目改名为Moby, 交给社区自行维护, 而Docker公司的商业产品将占有Docker这个注册商标.

容器技术圈子在短短几年里发生了很多变数, 想Docker这样一家创业公司, 在通过开源社区的运作取得巨大成功之后, 就不得不面对来自整个云计算产业的竞争和围剿. 只不过Docker公司最后选择的对抗方式是将开源项目与商业产品紧密绑定, 打造了一个极端封闭的技术生态. 这其实违背了Docker项目与开发者保持亲密关系的初衷. 相比之下, Kubernetes社区却是以一种更加温和的方式, 承接了Docker项目未尽的事业, 以开发者为核心, 构建一个相对民主和开发的容器生态.







































