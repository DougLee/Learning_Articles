# 各种设计模式之间的关联

设计模式不要生搬硬套.

复杂问题简单化.

## 工厂模式

原始社会 -> 农耕社会 -> 小作坊 -> 工厂 -> 流水线生产

Spring: BeanFactory  FactoryBean



## 单例模式

提高资源重复利用, 通过技术手段保证在系统运行阶段只有一个实例.

场景: 配置文件, 监控程序, IOC容器, 日历

实现手段: 懒汉式, 饿汉式, 注册登记式 反序列化处理

## 原型模式

复制.

Spring中原型模式的使用, 主要是为了配置信息能够被重复使用, 而且互不干扰



技术手段:  

实现cloneable 重写clone方法

字节码操作实现

通过反射机制实现(Spring中常用)

## 代理模式

应用场景: 中介 黄牛 经纪人

代码场景: 字节码增强 动态实现非侵入式编程

技术手段:

JDK Proxy Cglib, AspectJ, asm

效率性能最高: 内部类



## 策略模式

将一些固定的算法统一起来

应用场景: 旅游路线的选择, 出行方式的选择, 

代码场景: 支付方式的选择

特点:巧妙的避免if else 或者switch



## 模板方法

流程固定, 某个环节有差异

应用场景: jdbcTemplate, 工作流

代码: Spring JdbcTemplate简单实现



## 委派模式

有点像代理模式 又有点像策略模式. 代理和策略的一个特殊组合



代理的模式特殊情况, 全权代理

应用场景: 项目经理, Dispatcher

代码场景: Spring中的ServletDispatcher,  Delegate命名结尾的都是委派模式

## 适配器模式

兼容 转换

应用场景: 转接头 编码解码

代码场景: 登录, 兼容旧系统的登录功能



## 装饰器模式

委派模式 + 适配器模式 = 装饰器模式

注重覆盖, 扩展

is-a 同源同宗

应用场景: IO流 数据源

## 观察者模式

针对目标对象的一举一动 要得到一个反馈

应用场景: 事件监听 日志监听 短信通知



## Spring中常用的设计模式

AOP IOC DI

### AOP 面向切面编程  -- 面向规则编程

解耦 专人干专事;  规则



### IOC 控制反转

创建对象的控制权反转 new的权利

Spring中所有的Bean都由Spring来new, 所以才叫做控制反转. new出来以后的对象需要统一管理起来, 所以才有了Ioc容器(Map)



### DI 

解决对象动态赋值的问题, 动态调用getter setter(采用反射)



Spring加载步骤: 定位 载入 注册 初始化













