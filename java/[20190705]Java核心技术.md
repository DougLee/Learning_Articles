#  Java核心技术

## Java基础

### 1. 对Java平台的理解

Java中一种面向对象的语言, 最显著的特性有两个方面, 一个是所谓的"Write once, run anywhere", 即跨平台能力; 另一个就是GC, Java通过垃圾回收器回收分配内存.

我们日常会接触到JRE和JDK. JRE, Java运行环境, 包含了JVM和Java类库以及一些模块. JDK, 可以看做是JRE的一个超集, 提供了更多工具, 比如编译器, 各种诊断工具.

##### Java中解析运行吗?

不是

1. Java源代码经过Javac编译成.class文件
2. .class文件经JVM解析或者编译运行
   1. 解析: .class文件经过JVM内嵌的解析器解析执行
   2. 编译: 存在JIT编译器(Just In Time Compile 即时编译器) 把经常运行的代码作为热点代码 编译为与本地平台相关的机器码, 并进行各种层次的优化
   3. AOT编译器: Java 9 提供的直接将所有代码编译成机器码执行

### 2. Exception和Error的区别, 运行时异常和一般异常有什么不同

Exception和Error都是继承了Throwable类, 在Java中只有Throwable类型的实例才可以被抛出或者捕获, 它是异常处理机制的基本组成类型.

Exception和Error提现了Java平台设计者对不同异常情况的分类. Exception是程序正常运行中, 可以预料的意外情况, 可能并且应该被捕获并进行相应处理.

Error是指在正常情况下, 不大可能出现的情况, 绝大部分的Error都会导致程序处于非正常的, 不可恢复状态. 既然是非正常情况, 所以不便于也不需要捕获, 常见的比如OutOfMemeoryError, 都是Error的子类.

Exception又分为可检查异常和不检查异常. 可检查异常在源代码里必须显示的进行捕获处理, 这是编译期检查的一部分. 不检查异常就是所谓的运行时异常, 类似NullPointException之类, 通常是可以编码避免的逻辑错误, 具体根据需要来判断是否需要捕获, 并不会再编译期强制要求.

##### NoClassDefFoundError和ClassNotFoundException的区别

NoClassDefFoundError是一个Error, ClassNotFoundException是一个Exception.

+ NoClassDefFoundError产生的原因

如果JVM或者ClassLoader实例尝试加载类的时候却找不到类的定义. 要查找的类在编译的时候是存在的, 运行的时候却找不到了就会导致NoClassDefFoundError.

造成该问题的原因可能是打包过程漏掉了部分类, 或者jar包出现损坏或者被篡改. 解决这个问题的办法是查找哪些在开发期间存在于类路径下但是运行期间却不存在类路径下的类.

+ ClassNotFoundException产生的原因

Java支持使用Class.forName方法来动态地加载类, 任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到JVM内存中, 如果这个类在类路径中没有被找到, 那么此时就会在运行时抛出ClassNotFoundException异常.

解决该问题需要确保所需要的类连同它的依赖包存在于类路径中, 常见问题在于类路径名写错.  另外一个常见的原因是当一个类已经被某个类加载器加载到内存中了, 此时另一个类加载器又尝试着动态地从同一个包中加载这个类. 解决办法是控制动态类加载过程.

##### 异常处理的一些最佳实践

1. 尽量不要捕获类似Exception这样的通用异常, 而是应该捕获特定异常.
2. 不要只捕获而不处理异常
3. 异常信息最好使用产品日志, 详细输出到日志系统中.
4. Throw early catch late
5. 不建议用异常来控制业务流程.



### 3. 谈谈final, finally, finalize有什么不同

final可以用来修饰类, 方法, 变量, 分别有不同的意义. 

+ final修饰的类代表不可以继承修改
+ final修饰的变量不可以修改
+ final修饰的方法不可以重写(override)

finally是Java保证重点代码一定要被执行的一种机制. 可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接, 保证unlock锁等动作.

finallize是基础类Object的一个方法, 它的设计目的是保证对象在被垃圾收集前完成特定资源的回收. finalize机制现在已经不推荐使用, 并且在Java9中被deprecated.

#### final不等于不可修改

#### 实现不可修改的类

1. class自身声明为final, 
2. 将所有成员变量定义为private和final, 且不要实现setter方法

#### 替代finalize的方案

java.lang.ref.Cleaner

### 4. 强引用, 软引用, 弱引用,  幻象引用有什么区别, 具体使用场景是什么

不同的引用类型, 主要体现的是对象不同的可达性(reachable)状态和对垃圾收集的影响.

强引用: 就是我们常见的普通对象引用, 只要还有强引用指向一个对象, 就能表名对象还活着, 垃圾收集器不会碰这种对象. 对于一个普通的对象, 如果没有其他的引用关系, 只要超过了引用的作用域活着显示地将相应强引用赋值为null, 就是可以被GC的了, 当然具体的回收时机需要看具体的回收策略.

软引用: 相对强引用弱化一些的引用, 可以让对象豁免一些垃圾收集, 只有当JVM认为内存不足时, 才回去视图回收软引用指向的对象. JVM会确保在抛出OutOfMemoryError之前清理软引用指向的对象. 软引用通常用来实现内存敏感的缓存, 如果还有空闲内存, 就可以暂时保留缓存, 当内存不足时清理掉, 这样就保证了使用缓存的同时, 不会耗尽内存.

弱引用: 不能使对象豁免GC, 仅仅是提供一种访问在弱引用状态下对象的途径. 这就可以用来构建一种没有特定约束的关系, 比如, 维护一种非强制性的映射关系, 如果视图获取时对象还在, 就是用它, 否则重新实例化. 它同样是很多缓存实现的选择.

幻象引用: 又叫做虚引用, 你不能通过它访问对象. 幻象引用仅仅是提供了一种确保对象被finalize以后, 做某些事情的机制, 如果, 通常用来做所谓的Post-Mortem清理机制.



### 5.  String, StringBuffer, StringBuilder有什么区别

String是不可变的类, 被声明成final class, 其属性也都是final.  由于它的不可变性, 类似拼接, 裁剪字符串等操作都会产生新的String对象, 相关操作的效率往往对应用性能有明显影响.

StringBuffer是为解决String拼接产生中间对象的问题而提供的一个类,  可以使用append或者add方法, 把字符串添加到已有序列的末尾或指定位置. SringBuffer本质是一个线程安全的可修改字符序列, 它保证了线程安全也相应的有额外的性能开销. 所以除非有线程安全的需要, 不然还是推荐使用StringBuilder

StringBuilder是Java1.5新增的, 和StringBuffer没有本质区别, 去掉了线程安全的部分, 减小了开销.



### 6. 谈谈Java反射机制, 动态代理是基于什么原理

反射是Java语言提供的一种基础功能, 赋予程序在运行时自省的能力. 通过反射可以直接操作类或者对象.

动态代理是一种方便运行时动态构建代理, 动态处理方法调用的机制, 很多场景都是利用类似机制做到的, 如包装RPC的调用, AOPO等.

实现动态代理的方式很多, 如JDK自身提供的动态代理使用了反射机制. 还有其他的实现方式, 如字节码操作机制, 类似cglib等.

#### 动态代理解决了什么问题

动态代理首先是一个代理机制, 通过代理可以让调用者与实现者之间实现解耦.

Spring AOP支持两种模式的动态代理:JDK Proxy 和cglib.

### 7. int和Integer有什么区别, 谈谈Integer的值缓存范围

int是Java8种原始数据类型之一(boolean, byte, short, char, int, float, double, long). Java号称一切都是对象, 但原始数据类型是例外.

Integer是int的包装类, 它有一个int类型的字段存储数据, 并提供了基本操作. Java5中引入了自动装箱和自动拆箱功能, Java可以根据上下文自动进行转换, 极大的简化了相关编程.

Integer的缓存是Java5中的一个改进. 构建Integer对象的传统方式是直接调用构造器new一个对象. 但是实践发现大部分数据操作都集中在有限的, 较小的数值范围, 因此Java 5中新增了静态工厂方法valueOf, 在调用它的时候回利用缓存机制, 带来了明显的性能提升. 缓存值默认在-128到127之间.

#### 理解装箱, 拆箱以及它们发生在类的哪个阶段



## Java 进阶

## Java应用开发扩展

## Java安全基础

## Java性能基础











