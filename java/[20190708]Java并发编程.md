# Java并发编程

## 一   并发理论基础

### 1. 并发编程的三个重要特性: 可见性, 原子性和有序性

#### 原子性

在一次或者多次操作中, 所有的操作要么全部执行, 要么全部不执行.

线程切换带来原子性问题.

1. 多个原子性的操作在一起就不再是原子性的操作
2. 简单的读取与赋值操作是原子性的, 将一个变量赋值给另一个变量不是原子性的.
3. JMM只保证了基本读取和赋值的原子性操作. 如果想要使得某些代码片段具有原子性, 需要使用synchronized关键字

#### 可见性

可见性是指当一个线程对共享变量进行了修改, 那么另外的线程可以立即看到修改后的最新值.

缓存导致可见性问题.

Java提供了三种方式来保证可见性:

1. **使用关键字volatile**. 被volatile修饰的变量对于共享资源的读操作会直接在主内存中进行, 对于共享资源的写操作需要先修改工作内存, 但是修改结束后会立即将其刷新到主内存中.
2. **通过synchronized关键字保证可见性**. synchronized关键字能够保证同一时刻只有一个线程获得所, 然后执行同步方法, 并且还会确保在锁释放之前,会将对变量的修改刷新到主内存中.
3. **通过JUC提供的显示锁Lock也能够保证可见性**. Lock的lock方法能够保证在同一时刻只有一个线程获得锁然后执行同步方法, 并且会确保在锁释放之前会将对变量的修改刷新到主内存当中.

#### 有序性

有序性是指程序代码在执行过程中的先后顺序未必就是开发者编写代码的顺序.(由于Java在编译器以及运行期的优化).即**指令重排序**.

编译优化带来的有序性问题.

Java提供三种方式来保证有序性:

1. 使用volatile关键字保证有序性
2. 使用synchronized关键字保证有序性
3. 使用显示锁Lock保证有序性

### 2 . Java内存模型(JMM), 解决可见性和有序性的方法

产生可见性和有序性的原因是缓存和编译优化. 直接禁用缓存和编辑优化显然不太合适, 合理的方案应该是**按需禁用缓存和编辑优化**. 

JMM是个很复杂的规范, 可以有不同的视角解读, 站在程序开发的角度上可以理解为, JMM规范了JVM如何提供按需禁用缓存和编译优化的方法. 具体来说方法包括: **volatile**, **synchronized**和**final**关键字以及**Happens-Before**规则.

#### volatile关键字

volatile只能修饰类变量和实例变量. volatile修饰的变量具备两层语义:

1. 保证了不同线程之间对共享变量操作时的可见性.
2. 禁止对指令进行重排序.

所以volatile可以保证**可见性**和**有序性**.



####　Ｈappens-Before 规则

JMM具备一些天生的有序性规则, 不需要任何同步手段就能保证

##### 1) 程序次序规则:

在一个线程内, 代码按照便携式的次序执行, 编写在后边的操作发生在前面的操作之后.  看起来程序是按照代码编写的顺序执行, 但是JVM还是可能会进行指令重排序, 只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可.

##### 2) 锁定规则

一个unlock操作要先行发生于对同一个锁的lock操作.

##### 3) volatile变量规则

对一个volatile变量的写操作要早于读操作.

##### 4) 传递规则

如果A happerns-before B , B happens-before C 那么, A happens-before C.

##### 5) 线程启动规则

Thread对象的start()方法先发生于对该线程的任何操作.

##### 6) 线程中断规则

对线程执行interrupt()方法肯定要优先于捕获到中断信号. 如果线程收到了中断信号, 那么在此之前一定会先执行interrupt()方法.

##### 7) 线程的终结规则

县城中所有的操作都先行发生于线程的终止检测,  我们可以通过Thread.join()方法结束, Thread.isAlive()返回值手段来检测线程已经终止执行.

##### 8) 对象的终结规则

一个对象的初始化完成先行发生于finalize()方法的开始



### 3. 互斥锁

Java提供的互斥锁机制

#### synchronized关键字

synchronized 当修饰静态方法的时候, 锁定的是当前类的Class对象;

当修饰非静态方法的时候, 锁定的是当前实例对象this.



#### 死锁发生的条件:

1. 互斥, 共享资源X和Y只能被一个线程占用
2. 占有且等待, 线程T1已经取得共享资源X, 在等待共享资源Y的时候, 不释放 共享资源X
3. 不可抢占, 其他线程不能强行抢占线程T1占有的资源
4. 循环等待, 线程T1等待线程T2的资源, 线程T2等待线程T1的资源.

#### 预防死锁:

1. 破坏占用且等待条件
2. 破坏不可抢占条件
3. 破坏循环等待条件.

### 4. 安全性, 活跃性以及性能问题

*并发编程微观上涉及到原子性, 可见性, 有序性三个问题. 宏观上则表现为安全性, 活跃性和性能问题.*

#### 安全性问题

安全性问题本质上就是正确性, 而正确性的含义就是程序按照我们期望的执行.

数据竞争, 竞态条件

#### 活跃性问题

所谓活跃性问题是指某个操作无法执行下去. 例如**死锁**, 除了死锁外还有**活锁**和**饥饿**.

#### 性能问题

锁的过度使用可能导致串行化的范围过大, 以至于出现性能问题.

解决方案:

1. 既然锁会带来性能问题, 那最好的方案就自然就是使用无锁的算法和数据结构
2. 减少锁持有的世界.

性能方面三个非常重要的指标:

1. 吞吐量: 单位世界内能处理的请求数量. 吞吐量越高, 性能越好
2. 延迟: 从发出请求到收到响应的时间. 延迟越小, 性能越高
3. 并发量:  能同时处理的请求数量. 一般来说随着并发量的增加, 延迟也会增加, 所以延迟一般都是基于并发量来说的. 

### 5. 管程

**并发编程领域的两大核心问题: 互斥和同步.** 这两大问题管程都可以解决.

管程, 指的是管理共享变量以及对共享变量的操作过程, 让他们支持并发.

### 6. Java中的线程

#### 通用的线程的生命周期

五种状态: 初始状态, 可运行状态, 运行状态, 休眠状态和终止状态.

1. 初始状态: 线程已经被创建, 但是还不允许分配CPU执行. 这里的创建仅仅是在编程语言层面被创建, 在操作系统层面, 真正的线程还没有创建.
2. 可运行状态: 指线程可以分配CPU执行. 真正的操作系统已经被成功创建了, 可以分配CPU执行.
3. 运行状态: 有空闲的CPU时, 操作系统会给其分配一个处于可运行状态的线程, 被分配到CPU的线程的状态就是运行状态
4. 休眠状态: 运行状态的线程如果调用一个阻塞的API或者等待某个事件, 线程的状态就会转换成休眠状态.
5. 终止状态: 线程执行完或者线程出现异常就会进入终止状态.

#### Java中线程的生命周期

Java语言中线程有六种状态:

1. NEW (初始状态)
2. RUNNABLE (可运行/运行状态)
3. BLOCKED (阻塞状态)
4. WAITING 
5. TIMED_WAITING
6. TERMINATED (终止状态)

Java种的BLOCKED, WAITING, TIMED_WAITING三种状态实际上就是上边提到的休眠状态.

#### 为什么使用多线程

提升性能. 降低延迟, 提高吞吐量.

#### 多线程的应用场景

多线程主要解决CPU和I/O设备综合利用率的问题.

#### 创建多少线程合适

CPU密集型: 线程的数量=CPU核数

I/O密集型: 最佳线程数 = 1 + (I/O耗时/CPU耗时)



## 二  并发工具类

### 1. Lock和Condition

并发编程中的两大问题: 互斥和同步. 管程可以解决这两大问题. Java SDK并发包通过Lock和Condition两个接口来实现管程, 其中Lock用于解决互斥问题, Condition用于解决同步问题.

####  Lock

锁时用来控制多个线程访问共享资源的方式.

Lock接口提供的synchronized不具备的主要特性:

1. 尝试非阻塞的获取锁
2. 能被中断的获取锁
3. 超时获取锁.

### 2  信号量 (Semaphore)

信号量的模型可以简单概括为: 一个计数器, 一个等待队列, 三个方法. 其中智能通过三个方法访问信号量的计数器和等待队列, 且这三个方法都是原子性的.

三个方法是:

1. init(): 设置计数器的初始值
2. down(): 计数器的值减1; 如果此时计数器的值小于0, 当前线程将被阻塞, 否则当前线程可以继续执行
3. up(): 计数器的值加1; 如果此时计数器的值大于等于0, 则唤醒等待队列中的一个线程, 并将其从等待队列移出.

在Java SDK并发包中down()和up()分别对应acquire()和release().





## 三  并发设计模式



