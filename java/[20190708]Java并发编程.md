# Java并发编程

## 一   并发理论基础

### 1. 并发编程的三个重要特性: 可见性, 原子性和有序性

#### 原子性

在一次或者多次操作中, 所有的操作要么全部执行, 要么全部不执行.

线程切换带来原子性问题.

1. 多个原子性的操作在一起就不再是原子性的操作
2. 简单的读取与赋值操作是原子性的, 将一个变量赋值给另一个变量不是原子性的.
3. JMM只保证了基本读取和赋值的原子性操作. 如果想要使得某些代码片段具有原子性, 需要使用synchronized关键字

#### 可见性

可见性是指当一个线程对共享变量进行了修改, 那么另外的线程可以立即看到修改后的最新值.

缓存导致可见性问题.

Java提供了三种方式来保证可见性:

1. **使用关键字volatile**. 被volatile修饰的变量对于共享资源的读操作会直接在主内存中进行, 对于共享资源的写操作需要先修改工作内存, 但是修改结束后会立即将其刷新到主内存中.
2. **通过synchronized关键字保证可见性**. synchronized关键字能够保证同一时刻只有一个线程获得所, 然后执行同步方法, 并且还会确保在锁释放之前,会将对变量的修改刷新到主内存中.
3. **通过JUC提供的显示锁Lock也能够保证可见性**. Lock的lock方法能够保证在同一时刻只有一个线程获得锁然后执行同步方法, 并且会确保在锁释放之前会将对变量的修改刷新到主内存当中.

#### 有序性

有序性是指程序代码在执行过程中的先后顺序未必就是开发者编写代码的顺序.(由于Java在编译器以及运行期的优化).即**指令重排序**.

编译优化带来的有序性问题.

Java提供三种方式来保证有序性:

1. 使用volatile关键字保证有序性
2. 使用synchronized关键字保证有序性
3. 使用显示锁Lock保证有序性

### 2 . Java内存模型(JMM), 解决可见性和有序性的方法

产生可见性和有序性的原因是缓存和编译优化. 直接禁用缓存和编辑优化显然不太合适, 合理的方案应该是**按需禁用缓存和编辑优化**. 

JMM是个很复杂的规范, 可以有不同的视角解读, 站在程序开发的角度上可以理解为, JMM规范了JVM如何提供按需禁用缓存和编译优化的方法. 具体来说方法包括: **volatile**, **synchronized**和**final**关键字以及**Happens-Before**规则.

#### volatile关键字

volatile只能修饰类变量和实例变量. volatile修饰的变量具备两层语义:

1. 保证了不同线程之间对共享变量操作时的可见性.
2. 禁止对指令进行重排序.

所以volatile可以保证**可见性**和**有序性**.



####　Ｈappens-Before 规则

JMM具备一些天生的有序性规则, 不需要任何同步手段就能保证

##### 1) 程序次序规则:

在一个线程内, 代码按照便携式的次序执行, 编写在后边的操作发生在前面的操作之后.  看起来程序是按照代码编写的顺序执行, 但是JVM还是可能会进行指令重排序, 只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可.

##### 2) 锁定规则

一个unlock操作要先行发生于对同一个锁的lock操作.

##### 3) volatile变量规则

对一个volatile变量的写操作要早于读操作.

##### 4) 传递规则

如果A happerns-before B , B happens-before C 那么, A happens-before C.

##### 5) 线程启动规则

Thread对象的start()方法先发生于对该线程的任何操作.

##### 6) 线程中断规则

对线程执行interrupt()方法肯定要优先于捕获到中断信号. 如果线程收到了中断信号, 那么在此之前一定会先执行interrupt()方法.

##### 7) 线程的终结规则

县城中所有的操作都先行发生于线程的终止检测,  我们可以通过Thread.join()方法结束, Thread.isAlive()返回值手段来检测线程已经终止执行.

##### 8) 对象的终结规则

一个对象的初始化完成先行发生于finalize()方法的开始



### 3. 互斥锁

synchronized 当修饰静态方法的时候, 锁定的是当前类的Class对象;

当修饰非静态方法的时候, 锁定的是当前实例对象this.



## 二  并发工具类



## 三  并发设计模式

